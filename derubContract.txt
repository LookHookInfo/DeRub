0x4983F5B7c774cec0E7dDEE1f6Df61B773C335560

[
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "approve",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "borrowDRUB",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "hashAmount",
				"type": "uint256"
			}
		],
		"name": "buyDRUB",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "depositCollateral",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_hash",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_treasury",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_pool",
				"type": "address"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "allowance",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "needed",
				"type": "uint256"
			}
		],
		"name": "ERC20InsufficientAllowance",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "balance",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "needed",
				"type": "uint256"
			}
		],
		"name": "ERC20InsufficientBalance",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "approver",
				"type": "address"
			}
		],
		"name": "ERC20InvalidApprover",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "receiver",
				"type": "address"
			}
		],
		"name": "ERC20InvalidReceiver",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			}
		],
		"name": "ERC20InvalidSender",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			}
		],
		"name": "ERC20InvalidSpender",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "user",
				"type": "address"
			}
		],
		"name": "liquidate",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "SafeERC20FailedOperation",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "maxCount",
				"type": "uint256"
			}
		],
		"name": "liquidateBatch",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "repay",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newPool",
				"type": "address"
			}
		],
		"name": "setPool",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newTreasury",
				"type": "address"
			}
		],
		"name": "setTreasury",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "transfer",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "transferFrom",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "withdrawCollateral",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			}
		],
		"name": "allowance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "collateral",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "COLLATERAL_FACTOR",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "debt",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "debtorIndex",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "debtors",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "debtorsLength",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "decimals",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "index",
				"type": "uint256"
			}
		],
		"name": "getDebtor",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "start",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "count",
				"type": "uint256"
			}
		],
		"name": "getDebtors",
		"outputs": [
			{
				"internalType": "address[]",
				"name": "list",
				"type": "address[]"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getDrubPerHash",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "drubPerHashScaled",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "getHashPerDrubScaled",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "priceScaled",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "HASH",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "HASH_DECIMALS",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "inDebtors",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "u",
				"type": "address"
			}
		],
		"name": "maxDebt",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "name",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "pool",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "symbol",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalSupply",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "treasury",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
]


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

/**
 * DeRub
 * @dev Decentralized DRUB token backed by HASH
 */

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface IUniswapV3PoolMinimal {
    function slot0() external view returns (
        uint160 sqrtPriceX96,
        int24, uint16, uint16, uint16, uint8, bool
    );
    function liquidity() external view returns (uint128);
}

contract DeRub is ERC20, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // === IMMUTABLES ===
    address public immutable HASH;         // HASH token address
    uint8   public constant HASH_DECIMALS = 18; // HASH decimals fixed to 18

    // === STATE ===
    address public treasury;              // Treasury address
    address public pool;                  // Uniswap V3 pool (token0 = DRUB, token1 = HASH)
    address public owner;                 // Owner until renounceOwnership

    uint256 public constant COLLATERAL_FACTOR = 80; // Max borrowable % of collateral

    mapping(address => uint256) public collateral; // User HASH collateral
    mapping(address => uint256) public debt;       // User DRUB debt

    // === Debtors list ===
    address[] public debtors;
    mapping(address => bool) public inDebtors;     // flag if an address is in debtors
    mapping(address => uint256) public debtorIndex; // 1-based index in debtors array (0 = not present)

    // === CONSTRUCTOR ===
    constructor(
        address _hash,
        address _treasury,
        address _pool
    ) ERC20("De Ruble", "DRUB") {
        require(_hash != address(0), "ZERO_HASH");
        require(_treasury != address(0), "ZERO_TREASURY");
        require(_pool != address(0), "ZERO_POOL");

        HASH = _hash;
        treasury = _treasury;
        pool = _pool;
        owner = msg.sender;
    }

    // =================================================
    //                  MODIFIERS
    // =================================================

    modifier onlyOwner() {
        require(msg.sender == owner, "NOT_OWNER");
        _;
    }

    // ---------------- OWNER FUNCTIONS ----------------

    /// @notice Update Uniswap V3 pool for price oracle
    function setPool(address newPool) external onlyOwner {
        require(newPool != address(0), "ZERO");
        pool = newPool;
    }

    /// @notice Update treasury address
    function setTreasury(address newTreasury) external onlyOwner {
        require(newTreasury != address(0), "ZERO");
        treasury = newTreasury;
    }

    /// @notice Renounce ownership to make contract fully decentralized
    function renounceOwnership() external onlyOwner {
        owner = address(0);
    }

    // ---------------- ORACLE (SPOT, SAFE) ----------------

    function getHashPerDrubScaled() public view returns (uint256 priceScaled) {
        IUniswapV3PoolMinimal P = IUniswapV3PoolMinimal(pool);
        require(P.liquidity() > 0, "NO_LIQ");
        (uint160 sqrtPriceX96,, , , , , ) = P.slot0();

        uint256 a = (uint256(sqrtPriceX96) * 1e18) / (2**96);
        uint256 b = uint256(sqrtPriceX96) / (2**96);

        priceScaled = a * b;
        require(priceScaled > 0, "PRICE0");
    }

    function getDrubPerHash() public view returns (uint256 drubPerHashScaled) {
        uint256 hashPerDrub = getHashPerDrubScaled();
        require(hashPerDrub > 0, "PRICE0");
        drubPerHashScaled = (1e36) / hashPerDrub;
    }

    function _hashToDrub(uint256 h) internal view returns (uint256) {
        uint256 drubPerHash = getDrubPerHash();
        return (h * drubPerHash) / 1e18;
    }

    // ---------------- DEBTORS LIST HELPERS ----------------

    /// @notice Add user to debtors array if not present. 1-based index stored.
    function _addDebtor(address user) internal {
        if (debtorIndex[user] == 0) {
            debtors.push(user);
            debtorIndex[user] = debtors.length; // 1-based
            inDebtors[user] = true;
        }
    }

    /// @notice Remove user from debtors array (swap & pop). Safe when user not present.
    function _removeDebtor(address user) internal {
        uint256 idx = debtorIndex[user];
        if (idx == 0) {
            // not present
            inDebtors[user] = false;
            return;
        }
        uint256 last = debtors.length;
        if (idx < last) {
            address lastAddr = debtors[last - 1];
            debtors[idx - 1] = lastAddr;
            debtorIndex[lastAddr] = idx;
        }
        debtors.pop();
        debtorIndex[user] = 0;
        inDebtors[user] = false;
    }

    /// Public getters for debtors
    function debtorsLength() external view returns (uint256) {
        return debtors.length;
    }

    function getDebtor(uint256 index) external view returns (address) {
        return debtors[index];
    }

    // ---------------- INTERNAL AUTO-LIQUIDATION ----------------

    /// @notice Auto-liquidate a user if debt exceeds max allowed
    function _autoLiquidate(address user) internal {
        uint256 d = debt[user];
        if (d == 0) {
            // nothing to do
            return;
        }
        if (d <= maxDebt(user)) {
            // healthy
            return;
        }

        uint256 seized = collateral[user];

        // zero out position
        collateral[user] = 0;
        debt[user] = 0;

        // transfer HASH collateral to treasury
        if (seized > 0) {
            IERC20(HASH).safeTransfer(treasury, seized);
        }

        // mint DRUB equivalent to treasury (as in V1)
        uint256 drubAmount = 0;
        if (seized > 0) {
            drubAmount = _hashToDrub(seized);
            _mint(treasury, drubAmount);
        }

        // remove from debtors list if present
        if (inDebtors[user]) {
            _removeDebtor(user);
        }
    }

    /// @notice Maximum debt allowed for a user based on collateral
    function maxDebt(address u) public view returns (uint256) {
        return (_hashToDrub(collateral[u]) * COLLATERAL_FACTOR) / 100;
    }

    // ---------------- COLLATERAL ----------------

    /// @notice Deposit HASH as collateral
    function depositCollateral(uint256 amount) external {
        _autoLiquidate(msg.sender);
        IERC20(HASH).safeTransferFrom(msg.sender, address(this), amount);
        collateral[msg.sender] += amount;
    }

    /// @notice Withdraw HASH collateral with debt check
    function withdrawCollateral(uint256 amount) external {
        _autoLiquidate(msg.sender);
        require(collateral[msg.sender] >= amount, "NO_COLL");
        collateral[msg.sender] -= amount;
        require(debt[msg.sender] <= maxDebt(msg.sender), "UNDER");
        IERC20(HASH).safeTransfer(msg.sender, amount);
    }

    // ---------------- BORROW ----------------

    /// @notice Borrow DRUB against HASH collateral
    function borrowDRUB(uint256 amount) external {
        _autoLiquidate(msg.sender);
        require(debt[msg.sender] + amount <= maxDebt(msg.sender), "LIMIT");
        debt[msg.sender] += amount;
        _mint(msg.sender, amount);

        // add to debtors list if this is a borrower (debt > 0)
        if (debt[msg.sender] > 0) {
            _addDebtor(msg.sender);
        }
    }

    /// @notice Repay DRUB debt
    function repay(uint256 amount) external {
        _autoLiquidate(msg.sender);
        _burn(msg.sender, amount);
        require(debt[msg.sender] >= amount, "REPAY_TOO_MUCH");
        debt[msg.sender] -= amount;

        // remove from debtors if fully repaid
        if (debt[msg.sender] == 0 && inDebtors[msg.sender]) {
            _removeDebtor(msg.sender);
        }
    }

    // ---------------- BUY ----------------

    /// @notice Buy DRUB using HASH; DRUB equivalent goes to treasury
    function buyDRUB(uint256 hashAmount) external {
        _autoLiquidate(msg.sender);
        uint256 drubAmount = _hashToDrub(hashAmount);

        // 1. Transfer HASH to treasury
        IERC20(HASH).safeTransferFrom(msg.sender, treasury, hashAmount);

        // 2. Mint DRUB to user
        _mint(msg.sender, drubAmount);

        // 3. Mint DRUB equivalent to treasury
        _mint(treasury, drubAmount);
    }

    // ---------------- MANUAL LIQUIDATION ----------------

    /// @notice Anyone can manually liquidate a specific user
    function liquidate(address user) external nonReentrant {
        _autoLiquidate(user);
    }

    /// @notice Batch liquidation: scan the debtors list and liquidate up to maxCount users.
    /// Iteration uses swap-pop removal semantics; when a debtor is removed during iteration,
    /// the swapped-in address sits at the same index and will be checked next.
    function liquidateBatch(uint256 maxCount) external nonReentrant {
        uint256 len = debtors.length;
        if (len == 0 || maxCount == 0) return;

        uint256 i = 0;
        uint256 liquidated = 0;

        // loop while i < debtors.length and liquidated < maxCount
        while (i < debtors.length && liquidated < maxCount) {
            address user = debtors[i];
            // If user still liquidatable -> liquidate (this will remove them from array by swap-pop)
            if (debt[user] > 0 && debt[user] > maxDebt(user)) {
                // perform liquidation
                _autoLiquidate(user);
                liquidated++;
                // Note: _autoLiquidate removed 'user' and moved last element into index i,
                // so do NOT increment i here â€” need to re-check the new element at i.
            } else {
                // not liquidatable (or zero debt) -> move to next index
                i++;
            }
        }
    }

    // ---------------- VIEW HELPERS ----------------

    /// @notice Get list of debtors (careful: can be large)
    function getDebtors(uint256 start, uint256 count) external view returns (address[] memory list) {
        uint256 total = debtors.length;

        if (start >= total) {
            return new address[](0);
        }

        uint256 end = start + count;
        if (end > total) {
            end = total;
        }

        uint256 len = end - start;
        list = new address[](len);

        for (uint256 i = 0; i < len; i++) {
            list[i] = debtors[start + i];
        }
    }
}
