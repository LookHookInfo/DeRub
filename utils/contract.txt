// SPDX-License-Identifier: MIT
// Current contract version is MVP.
// Oracle is centralized in this version.

pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

interface IERC20Ext {
    function transferFrom(address, address, uint256) external returns (bool);
    function transfer(address, uint256) external returns (bool);
}

contract DecentralizedRubleLendingV15 is ERC20, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // --- Protocol parameters ---
    uint256 public constant COLLATERAL_FACTOR = 80; // Max borrow limit (80% of collateral value)
    // usdcMarkup stored in basis points (bps). 50 bps = 0.5%, 100 bps = 1%, 500 bps = 5%
    uint256 public usdcMarkup = 50;                 // starting markup: 50 bps = 0.5%

    // --- Admin / oracle ---
    address public immutable treasury;              // Treasury address where seized collateral is sent
    address public priceUpdater;                    // Oracle updater address (centralized in MVP)
    address public owner;                           // Contract owner (creator) with ability to change priceUpdater

    // --- Assets ---
    struct Asset {
        address token;   // Collateral token address (0 for ETH)
        uint8 decimals;  // Token decimals
    }
    Asset[] public assets;

    // --- User accounting ---
    mapping(address => mapping(address => uint256)) public collateralBalance; // user -> token -> amount
    mapping(address => uint256) public debtBalance;                           // user -> DRUB debt
    mapping(address => bool) public isBorrower;                               // tracks if user has debt
    mapping(address => uint256) public prices;                                // token -> DRUB price

    // --- Debtors list ---
    address[] public debtors;                          // list of debtors
    mapping(address => bool) public inDebtors;         // debtor flag
    mapping(address => uint256) public debtorIndex;    // debtor index in array

    // Example USDC address (mainnet/testnet as in your snippet)
    address public constant USDC = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913;

    /* ===== Events ===== */
    event Deposited(address indexed user, address indexed token, uint256 amount);
    event Withdrawn(address indexed user, address indexed token, uint256 amount);
    event Borrowed(address indexed user, uint256 amount);
    event Repaid(address indexed user, uint256 amount);
    event AutoLiquidated(address indexed user, uint256 debtCovered, uint256 valueSeizedDRUB);
    event PriceUpdated(address indexed token, uint256 price);
    event PriceUpdaterChanged(address indexed newUpdater);
    event BoughtDRUB(address indexed buyer, uint256 drubAmount, uint256 usdcAmount);
    event DRUBBurned(address indexed burner, uint256 amount);
    event OwnershipRenounced(address indexed previousOwner);
    event USDCMarkupChanged(uint256 newMarkup);

    /* ===== Errors ===== */
    error NotUpdater();
    error InvalidAddress();
    error InvalidAmount();
    error AssetNotAllowed();
    error InsufficientCollateral();
    error WouldBeUndercollateralized();
    error ETHTransferFailed();
    error USDCPriceZero();
    error LengthMismatch();
    error BadPrice();
    error NotEnoughDRUB();
    error MarkupTooHigh();

    constructor(address _treasury, address _priceUpdater) ERC20("Decentralized Ruble", "DRUB") {
        if (_treasury == address(0) || _priceUpdater == address(0)) revert InvalidAddress();
        treasury = _treasury;
        priceUpdater = _priceUpdater;
        owner = msg.sender; // set deployer as owner
        // usdcMarkup already initialized to 50 (50 bps = 0.5%) above

        // Whitelist collateral assets
        assets.push(Asset({token: 0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf, decimals: 8}));
        assets.push(Asset({token: address(0), decimals: 18})); // ETH
        assets.push(Asset({token: 0xA9B631ABcc4fd0bc766d7C0C8fCbf866e2bB0445, decimals: 18}));
    }

    // --- Modifiers ---
    modifier onlyPriceUpdater() {
        if (msg.sender != priceUpdater) revert NotUpdater();
        _;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotUpdater();
        _;
    }

    // --- Oracle ---
    /// @notice Set prices (only callable by current priceUpdater)
    function setPrices(address[] calldata tokens, uint256[] calldata newPrices) external onlyPriceUpdater {
        if (tokens.length != newPrices.length) revert LengthMismatch();
        uint256 len = tokens.length;
        for (uint256 i = 0; i < len; ) {
            uint256 p = newPrices[i];
            if (p == 0) revert BadPrice();
            prices[tokens[i]] = p;
            emit PriceUpdated(tokens[i], p);
            unchecked { ++i; }
        }
    }

    /// @notice Allow current owner (creator) to change the priceUpdater address.
    /// This makes it possible to switch to a decentralized oracle contract later.
    function changePriceUpdater(address newUpdater) external onlyOwner {
        if (newUpdater == address(0)) revert InvalidAddress();
        priceUpdater = newUpdater;
        emit PriceUpdaterChanged(newUpdater);
    }

    /// @notice Change USDC markup percentage (only owner, before ownership renounced)
    /// @param newMarkup basis points (bps). e.g. 50 = 0.5%, 100 = 1%
    function changeUSDCMarkup(uint256 newMarkup) external onlyOwner {
        if (newMarkup > 500) revert MarkupTooHigh(); // Max 5% markup (500 = 5%)
        usdcMarkup = newMarkup;
        emit USDCMarkupChanged(newMarkup);
    }

    /// @notice Permanently renounce owner rights. After calling this, owner becomes address(0)
    /// and no one with owner privileges can change the priceUpdater anymore.
    function renounceOwnership() external onlyOwner {
        address previous = owner;
        owner = address(0);
        emit OwnershipRenounced(previous);
    }

    // --- Collateral helpers ---
    function _toDRUB(address token, uint8 tokenDecimals, uint256 amount) internal view returns (uint256) {
        uint256 p = prices[token];
        if (p == 0) return 0;
        return amount * p / (10 ** uint256(tokenDecimals));
    }

    function totalCollateralValueDRUB(address user) public view returns (uint256 totalValue) {
        uint256 n = assets.length;
        for (uint256 i = 0; i < n; ) {
            address t = assets[i].token;
            uint256 amt = collateralBalance[user][t];
            if (amt != 0) {
                uint256 v = _toDRUB(t, assets[i].decimals, amt);
                totalValue += v;
            }
            unchecked { ++i; }
        }
    }

    function getMaxDebt(address user) public view returns (uint256) {
        return totalCollateralValueDRUB(user) * COLLATERAL_FACTOR / 100;
    }

    function isLiquidatable(address user) public view returns (bool) {
        return debtBalance[user] > getMaxDebt(user);
    }

    // --- Collateral management ---
    function depositCollateral(address token, uint256 amount) external payable nonReentrant {
        (bool allowed, uint8 decs) = _findAsset(token);
        if (!allowed) revert AssetNotAllowed();
        if (amount == 0) revert InvalidAmount();

        if (token == address(0)) {
            if (msg.value != amount) revert InvalidAmount();
        } else {
            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        }

        collateralBalance[msg.sender][token] += amount;
        emit Deposited(msg.sender, token, amount);
    }

    function withdrawCollateral(address token, uint256 amount) external nonReentrant {
        (bool allowed, ) = _findAsset(token);
        if (!allowed) revert AssetNotAllowed();
        if (amount == 0) revert InvalidAmount();
        if (collateralBalance[msg.sender][token] < amount) revert InsufficientCollateral();

        collateralBalance[msg.sender][token] -= amount;
        if (debtBalance[msg.sender] > getMaxDebt(msg.sender)) {
            collateralBalance[msg.sender][token] += amount;
            revert WouldBeUndercollateralized();
        }

        if (token == address(0)) {
            (bool ok, ) = payable(msg.sender).call{value: amount}("");
            if (!ok) revert ETHTransferFailed();
        } else {
            IERC20(token).safeTransfer(msg.sender, amount);
        }
        emit Withdrawn(msg.sender, token, amount);
    }

    // --- Borrow / Repay ---
    function borrowDrub(uint256 amount) external nonReentrant {
        if (amount == 0) revert InvalidAmount();
        if (debtBalance[msg.sender] + amount > getMaxDebt(msg.sender)) revert WouldBeUndercollateralized();

        debtBalance[msg.sender] += amount;
        isBorrower[msg.sender] = true;
        _mint(msg.sender, amount);
        emit Borrowed(msg.sender, amount);

        if (debtorIndex[msg.sender] == 0) {
            debtors.push(msg.sender);
            debtorIndex[msg.sender] = debtors.length;
            inDebtors[msg.sender] = true;
        }
    }

    function repayDebt(uint256 amount) external nonReentrant {
        if (amount == 0) revert InvalidAmount();
        if (debtBalance[msg.sender] < amount) revert InvalidAmount();
        if (balanceOf(msg.sender) < amount) revert NotEnoughDRUB();

        debtBalance[msg.sender] -= amount;
        _burn(msg.sender, amount);
        emit Repaid(msg.sender, amount);

        if (debtBalance[msg.sender] == 0) {
            isBorrower[msg.sender] = false;
            if (inDebtors[msg.sender]) {
                _removeDebtor(msg.sender);
            }
        }
    }

    function burnDRUB(uint256 amount) external nonReentrant {
        if (amount == 0) revert InvalidAmount();
        if (balanceOf(msg.sender) < amount) revert NotEnoughDRUB();
        _burn(msg.sender, amount);
        emit DRUBBurned(msg.sender, amount);
    }

    // --- Auto-liquidation (full liquidation) ---
    function autoLiquidate(address user) public nonReentrant {
        _autoLiquidateInternal(user);
    }

    function autoLiquidateAll(address[] calldata users) external nonReentrant {
        uint256 n = users.length;
        for (uint256 i = 0; i < n; ) {
            _autoLiquidateInternal(users[i]);
            unchecked { ++i; }
        }
    }

    function _autoLiquidateInternal(address user) internal {
        uint256 debt = debtBalance[user];
        if (debt == 0) return;

        // âœ… Liquidation allowed only if user is over 80% debt-to-collateral ratio
        if (!isLiquidatable(user)) {
            return;
        }

        uint256 totalVal = totalCollateralValueDRUB(user);

        // Fully close user's debt by minting DRUB internally and burning it
        _mint(address(this), debt);
        debtBalance[user] = 0;
        _burn(address(this), debt);

        // Seize all collateral and send to treasury
        uint256 n = assets.length;
        for (uint256 i = 0; i < n; i++) {
            address token = assets[i].token;
            uint256 bal = collateralBalance[user][token];
            if (bal > 0) {
                collateralBalance[user][token] = 0;
                _sendCollateralToTreasury(token, bal);
            }
        }

        emit AutoLiquidated(user, debt, totalVal);

        // Remove from debtors list
        if (inDebtors[user]) {
            _removeDebtor(user);
            isBorrower[user] = false;
        }
    }

    // --- Buy DRUB for USDC ---
    function buyDRUB(uint256 usdcAmount) external nonReentrant {
        if (usdcAmount == 0) revert InvalidAmount();
        uint256 usdcPrice = prices[USDC];
        if (usdcPrice == 0) revert USDCPriceZero();

        // Calculate base amount without markup
        uint256 baseAmount = usdcAmount * usdcPrice / 1e6;
        
        // Calculate protocol fee (usdcMarkup basis points of the total value)
        uint256 protocolFee = baseAmount * usdcMarkup / 10000; // Divided by 10000 for basis points
        
        // User receives base amount minus protocol fee
        uint256 drubAmount = baseAmount - protocolFee;

        IERC20(USDC).safeTransferFrom(msg.sender, treasury, usdcAmount);
        _mint(msg.sender, drubAmount);
        emit BoughtDRUB(msg.sender, drubAmount, usdcAmount);
    }

    // --- Views ---
    function getUserPosition(address user) external view returns (
        address[] memory tokens,
        uint256[] memory balances,
        uint256 debt,
        uint256 maxBorrow,
        uint256 totalValueDRUB
    ){
        uint256 n = assets.length;
        tokens = new address[](n);
        balances = new uint256[](n);
        for (uint256 i = 0; i < n; ) {
            tokens[i] = assets[i].token;
            balances[i] = collateralBalance[user][assets[i].token];
            unchecked { ++i; }
        }
        debt = debtBalance[user];
        totalValueDRUB = totalCollateralValueDRUB(user);
        maxBorrow = getMaxDebt(user);
    }

    /// @notice Returns current USDC markup in basis points (bps). e.g. 50 = 0.5%
    function getUSDCMarkupBps() external view returns (uint256) {
        return usdcMarkup;
    }

    function assetsCount() external view returns (uint256){
        return assets.length;
    }

    // --- Debtors management ---
    function _removeDebtor(address user) internal {
        uint256 idx = debtorIndex[user];
        if (idx == 0) {
            inDebtors[user] = false;
            return;
        }
        uint256 last = debtors.length;
        if (idx < last) {
            address lastAddr = debtors[last - 1];
            debtors[idx - 1] = lastAddr;
            debtorIndex[lastAddr] = idx;
        }
        debtors.pop();
        debtorIndex[user] = 0;
        inDebtors[user] = false;
    }

    function debtorsLength() external view returns (uint256) {
        return debtors.length;
    }

    function getDebtor(uint256 index) external view returns (address) {
        return debtors[index];
    }

    // --- Internal utils ---
    function _sendCollateralToTreasury(address token,uint256 amount) internal {
        if (token == address(0)) {
            (bool ok, ) = payable(treasury).call{value: amount}("");
            if (!ok) revert ETHTransferFailed();
        } else {
            IERC20(token).safeTransfer(treasury, amount);
        }
    }

    function _findAsset(address token) internal view returns(bool,uint8){
        uint256 n = assets.length;
        for (uint256 i = 0; i < n; ) {
            if (assets[i].token == token) return (true, assets[i].decimals);
            unchecked { ++i; }
        }
        return (false,0);
    }

    receive() external payable {}
}
